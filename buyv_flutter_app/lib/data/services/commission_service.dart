import 'package:flutter/foundation.dart';
import '../models/commission_model.dart';
import '../../services/api/commission_api_service.dart';

class CommissionService {
  final CommissionApiService _api = CommissionApiService();

  /// Create a commission record when a sale is made through a promotional reel
  Future<void> createCommission({
    required String userId,
    required String userName,
    required String postId,
    required String productId,
    required String productName,
    required double productPrice,
    double commissionRate = 0.01,
  }) async {
    // Commission records are generated by the backend when orders are created.
    debugPrint('createCommission is handled server-side during order creation.');
  }

  /// Get all commissions for a specific user
  Future<List<CommissionModel>> getUserCommissions(String userId) async {
    try {
      final list = await _api.listMyCommissions();
      return list.map(_mapToCommissionModel).toList();
    } catch (e) {
      throw Exception('Failed to get user commissions: $e');
    }
  }

  /// Get user's commission summary
  Future<UserCommissionSummary?> getUserCommissionSummary(String userId) async {
    try {
      final commissions = await getUserCommissions(userId);
      return _buildSummary(userId, commissions);
    } catch (e) {
      throw Exception('Failed to get user commission summary: $e');
    }
  }

  /// Update commission status (e.g., from pending to paid)
  Future<void> updateCommissionStatus(String commissionId, String newStatus) async {
    try {
      final ok = await _api.updateStatus(commissionId, newStatus);
      if (!ok) throw Exception('Backend rejected status update');
    } catch (e) {
      throw Exception('Failed to update commission status: $e');
    }
  }

  /// Get commissions by status
  Future<List<CommissionModel>> getCommissionsByStatus(String status) async {
    try {
      final all = await _api.listMyCommissions();
      return all
          .where((m) => (m['status'] as String?) == status)
          .map(_mapToCommissionModel)
          .toList();
    } catch (e) {
      throw Exception('Failed to get commissions by status: $e');
    }
  }

  /// Calculate total commissions for a user
  Future<double> calculateUserTotalCommissions(String userId) async {
    try {
      final commissions = await getUserCommissions(userId);
      return commissions
          .where((c) => c.status == 'paid')
          .fold<double>(0.0, (total, commission) => total + commission.commissionAmount);
    } catch (e) {
      throw Exception('Failed to calculate user total commissions: $e');
    }
  }

  /// Update user's commission summary
  // Summary calculation moved client-side

  /// Stream user commissions for real-time updates
  /// Note: Polls every 5 minutes to avoid excessive API calls
  Stream<List<CommissionModel>> streamUserCommissions(String userId) async* {
    // Initial load
    try {
      final list = await _api.listMyCommissions();
      yield list.map(_mapToCommissionModel).toList();
    } catch (e) {
      debugPrint('Error loading commissions: $e');
      yield [];
    }
    
    // Poll every 5 minutes (300 seconds) to reduce server load
    while (true) {
      await Future.delayed(const Duration(seconds: 300));
      try {
        final list = await _api.listMyCommissions();
        yield list.map(_mapToCommissionModel).toList();
      } catch (e) {
        debugPrint('Error polling commissions: $e');
        // Don't yield empty list on error, keep last state
      }
    }
  }

  /// Stream user commission summary for real-time updates
  Stream<UserCommissionSummary?> streamUserCommissionSummary(String userId) async* {
    await for (final list in streamUserCommissions(userId)) {
      yield _buildSummary(userId, list);
    }
  }

  // Helpers
  int _dateToMillis(dynamic v) {
    if (v == null) return 0;
    if (v is int) return v;
    if (v is String) {
      try { return DateTime.parse(v).millisecondsSinceEpoch; } catch (_) { return 0; }
    }
    if (v is DateTime) return v.millisecondsSinceEpoch;
    return 0;
  }

  CommissionModel _mapToCommissionModel(Map<String, dynamic> m) {
    final mapped = {
      'id': (m['id'] ?? '').toString(),
      'userId': m['userId'] ?? '',
      'userName': m['userName'] ?? '',
      'postId': m['postId'] ?? '',
      'productId': m['productId'] ?? '',
      'productName': m['productName'] ?? '',
      'productPrice': m['productPrice'] ?? 0,
      'commissionRate': m['commissionRate'] ?? 0.01,
      'commissionAmount': m['commissionAmount'] ?? 0,
      'status': m['status'] ?? 'pending',
      'createdAt': _dateToMillis(m['createdAt']),
      'paidAt': m['paidAt'] != null ? _dateToMillis(m['paidAt']) : null,
      'metadata': m['metadata'],
    };
    return CommissionModel.fromMap(mapped);
  }

  UserCommissionSummary _buildSummary(String userId, List<CommissionModel> list) {
    final totalEarned = list.fold<double>(0.0, (sum, c) => sum + c.commissionAmount);
    final pendingList = list.where((c) => c.status == 'pending').toList();
    final paidList = list.where((c) => c.status == 'paid').toList();
    final pendingAmount = pendingList.fold<double>(0.0, (sum, c) => sum + c.commissionAmount);
    final paidAmount = paidList.fold<double>(0.0, (sum, c) => sum + c.commissionAmount);
    return UserCommissionSummary(
      userId: userId,
      totalEarned: totalEarned,
      pendingAmount: pendingAmount,
      paidAmount: paidAmount,
      totalSales: list.length,
      pendingSales: pendingList.length,
      paidSales: paidList.length,
      lastUpdated: DateTime.now(),
    );
  }
}